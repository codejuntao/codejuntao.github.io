<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java学习Redis篇]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E5%AD%A6%E4%B9%A0Redis%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Redis是什么？Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库,非关系型数据库，并提供多种语言的API。 默认端口？默认过期时间？默认支持多大value？6379 不会过期。但是这样说有点绝对。一般情况是这样，当你配置中开启了超出最大内存限制就写磁盘的话，那么这些没有设置过期时间的key可能会被写到磁盘上。 redis的key和string类型value限制均为512MB。 怎么统计缓存命中率？Redis提供了INFO这个命令，能够随时监控服务器的状态，通过计算hits和miss，我们可以得到缓存的命中率。 使用redis有哪些好处？(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) (2) 支持丰富数据类型，支持string，list，set，sorted set，hash (3) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 (4) 可以持久化数据: ​ Redis 持久化的两种方式： ​ 1) RDB 格式：Redis DataBase，每过一段时间将内存中的数据写到硬盘上 ​ 2) AOF 格式：Append Only File，以日志的方式记录服务器上的每个操作，当服务器重启的时候，将日志中操作还原到内存中。 RDB 持久化机制优点: 1) 方便备份与恢复 整个 Redis 数据库将只包含一个文件，默认是 dump.rdb，这对于文件备份和恢复而言是非常完美的。因为我 们可以非常轻松的将一个单独的文件压缩后再转移到其它储介质上。一旦系统出现灾难性故障，我们可以非常 容易的进行恢复。 2) 性能最大化 对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是分叉出子进程，由子进程完成这些持久 化的工作，这样就可以极大的避免服务进程执行 IO 操作了。 3) 启动效率更高 相比于 AOF 机制，如果数据集很大，RDB 的启动效率会更高 使用redis有什么缺点？主要是四个问题(一)缓存和数据库双写一致性问题(二)缓存雪崩问题(三)缓存击穿问题(四)缓存的并发竞争问题 redis的数据类型，以及每种数据类型的使用场景?(一)String最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。 (二)hash这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 (三)list使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。 (四)set因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 (五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，参照另一篇《分布式之延时任务方案解析》，该文指出了sorted set可以用来做延时任务。最后一个应用就是可以做范围查找。 为什么使用Redis？在项目中使用redis，主要是从两个角度去考虑:性能和并发。 （一）性能 我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。 我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。 （二）并发 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。 单线程的redis为什么这么快？(一)纯内存操作(二)单线程操作，避免了频繁的上下文切换(三)采用了非阻塞I/O多路复用机制 redis的过期策略以及内存淘汰机制?redis采用的是定期删除+惰性删除策略。 为什么不用定时删除策略?定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略. 定期删除+惰性删除是如何工作的呢?定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。 redis和数据库双写一致性问题?从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。 除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。 采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 如何应对缓存穿透和缓存雪崩问题?缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。 解决方案:(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。 解决方案:(一)给缓存的失效时间，加上一个随机值，避免集体失效。(二)使用互斥锁，但是该方案吞吐量明显下降了。(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 I 从缓存A读数据库，有则直接返回 II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 III 更新线程同时更新缓存A和缓存B。 如何解决redis的并发竞争key问题?(1)如果对这个key操作，不要求顺序这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。(2)如果对这个key操作，要求顺序假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下 123系统A key 1 &#123;valueA 3:00&#125;系统B key 1 &#123;valueB 3:05&#125;系统C key 1 &#123;valueC 3:10&#125; 那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。 其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习Dubbo篇]]></title>
    <url>%2F2019%2F08%2F05%2FJava%E5%AD%A6%E4%B9%A0Dubbo%E7%AF%87%2F</url>
    <content type="text"><![CDATA[分布式RPC框架Apache Dubbo1. 软件架构的演进过程软件架构的发展经历了由单体架构、垂直架构、SOA架构到微服务架构的演进过程，下面我们分别了解一下这几个架构。 1.1 单体架构 架构说明： ​ 全部功能集中在一个项目内（All in one）。 架构优点： ​ 架构简单，前期开发成本低、开发周期短，适合小型项目。 架构缺点： ​ 全部功能集成在一个工程中，对于大型项目不易开发、扩展和维护。 ​ 技术栈受限，只能使用一种语言开发。 ​ 系统性能扩展只能通过扩展集群节点，成本高。 1.2 垂直架构 架构说明： ​ 按照业务进行切割，形成小的单体项目。 架构优点： ​ 技术栈可扩展（不同的系统可以用不同的编程语言编写）。 架构缺点： ​ 功能集中在一个项目中，不利于开发、扩展、维护。 ​ 系统扩张只能通过集群的方式。 ​ 项目之间功能冗余、数据冗余、耦合性强。 1.3 SOA架构SOA全称为Service-Oriented Architecture，即面向服务的架构。它可以根据需求通过网络对松散耦合的粗粒度应用组件(服务)进行分布式部署、组合和使用。一个服务通常以独立的形式存在于操作系统进程中。 站在功能的角度，把业务逻辑抽象成可复用的服务，通过服务的编排实现业务的快速再生，目的：把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用。 架构说明： ​ 将重复功能或模块抽取成组件的形式，对外提供服务，在项目与服务之间使用ESB（企业服务总线）的形式作为通信的桥梁。 架构优点： ​ 重复功能或模块抽取为服务，提高开发效率。 ​ 可重用性高。 ​ 可维护性高。 架构缺点： ​ 各系统之间业务不同，很难确认功能或模块是重复的。 ​ 抽取服务的粒度大。 ​ 系统和服务之间耦合度高。 1.4 微服务架构 架构说明： ​ 将系统服务层完全独立出来，抽取为一个一个的微服务。 ​ 抽取的粒度更细，遵循单一原则。 ​ 采用轻量级框架协议传输。 架构优点： ​ 服务拆分粒度更细，有利于提高开发效率。 ​ 可以针对不同服务制定对应的优化方案。 ​ 适用于互联网时代，产品迭代周期更短。 架构缺点： ​ 粒度太细导致服务太多，维护成本高。 ​ 分布式系统开发的技术成本高，对团队的挑战大。 2. Apache Dubbo概述2.1 Dubbo简介Apache Dubbo是一款高性能的Java RPC框架。其前身是阿里巴巴公司开源的一个高性能、轻量级的开源Java RPC框架，可以和Spring框架无缝集成。 什么是RPC？ RPC全称为remote procedure call，即远程过程调用。比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调用的数据。 需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 RPC是一个泛化的概念，严格来说一切远程过程调用手段都属于RPC范畴。各种开发语言都有自己的RPC框架。Java中的RPC框架比较多，广泛使用的有RMI、Hessian、Dubbo、webservice等。 Dubbo官网地址：http://dubbo.apache.org Dubbo提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。 2.2 Dubbo架构Dubbo架构图（Dubbo官方提供）如下： 节点角色说明： 节点 角色名称 Provider 暴露服务的服务提供方 Consumer 调用远程服务的服务消费方 Registry 服务注册与发现的注册中心 Monitor 统计服务的调用次数和调用时间的监控中心 Container 服务运行容器 虚线都是异步访问，实线都是同步访问蓝色虚线:在启动时完成的功能红色虚线(实线)都是程序运行过程中执行的功能 调用关系说明: 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 3. 服务注册中心Zookeeper通过前面的Dubbo架构图可以看到，Registry（服务注册中心）在其中起着至关重要的作用。Dubbo官方推荐使用Zookeeper作为服务注册中心。 3.1 Zookeeper介绍Zookeeper 是 Apache Hadoop 的子项目，是一个树型的目录服务，支持变更推送，适合作为 Dubbo 服务的注册中心，工业强度较高，可用于生产环境，并推荐使用 。 为了便于理解Zookeeper的树型目录服务，我们先来看一下我们电脑的文件系统(也是一个树型目录结构)： 我的电脑可以分为多个盘符（例如C、D、E等），每个盘符下可以创建多个目录，每个目录下面可以创建文件，也可以创建子目录，最终构成了一个树型结构。通过这种树型结构的目录，我们可以将文件分门别类的进行存放，方便我们后期查找。而且磁盘上的每个文件都有一个唯一的访问路径，例如：C:\Windows\itcast\hello.txt。 Zookeeper树型目录服务： 流程说明： 服务提供者(Provider)启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址 服务消费者(Consumer)启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址 监控中心(Monitor)启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址 3.2 安装Zookeeper下载地址：http://archive.apache.org/dist/zookeeper/ 本课程使用的Zookeeper版本为3.4.6，下载完成后可以获得名称为zookeeper-3.4.6.tar.gz的压缩文件。 安装步骤： 第一步：安装 jdk（略）第二步：把 zookeeper 的压缩包（zookeeper-3.4.6.tar.gz）上传到 linux 系统第三步：解压缩压缩包​ tar -zxvf zookeeper-3.4.6.tar.gz第四步：进入zookeeper-3.4.6目录，创建data目录​ mkdir data第五步：进入conf目录 ，把zoo_sample.cfg 改名为zoo.cfg​ cd conf​ mv zoo_sample.cfg zoo.cfg第六步：打开zoo.cfg文件, 修改data属性：dataDir=/root/zookeeper-3.4.6/data 3.3 启动、停止Zookeeper进入Zookeeper的bin目录，启动服务命令 ./zkServer.sh start 停止服务命令./zkServer.sh stop 查看服务状态：./zkServer.sh status 4. Dubbo快速入门Dubbo作为一个RPC框架，其最核心的功能就是要实现跨网络的远程调用。本小节就是要创建两个应用，一个作为服务的提供方，一个作为服务的消费方。通过Dubbo来实现服务消费方远程调用服务提供方的方法。 4.1 服务提供方开发开发步骤： （1）创建maven工程（打包方式为war）dubbodemo_provider，在pom.xml文件中导入如下坐标 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.5.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;version&gt;2.6.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.4.7&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;version&gt;0.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.12.1.GA&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.47&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.3.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;8081&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; （2）配置web.xml文件 12345678910111213&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext*.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; （3）创建服务接口 1234package com.itheima.service;public interface HelloService &#123; public String sayHello(String name);&#125; （4）创建服务实现类 12345678910package com.itheima.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.itheima.service.HelloService;@Servicepublic class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return "hello " + name; &#125;&#125; 注意：服务实现类上使用的Service注解是Dubbo提供的，用于对外发布服务 （5）在src/main/resources下创建applicationContext-service.xml 123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name="dubbodemo_provider" /&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address="zookeeper://192.168.134.129:2181"/&gt; &lt;!-- 注册 协议和port 端口默认是20880 --&gt; &lt;dubbo:protocol name="dubbo" port="20881"&gt;&lt;/dubbo:protocol&gt; &lt;!-- 扫描指定包，加入@Service注解的类会被发布为服务 --&gt; &lt;dubbo:annotation package="com.itheima.service.impl" /&gt;&lt;/beans&gt; （6）启动服务 tomcat7:run 4.2 服务消费方开发开发步骤： （1）创建maven工程（打包方式为war）dubbodemo_consumer，pom.xml配置和上面服务提供者相同，只需要将Tomcat插件的端口号改为8082即可 （2）配置web.xml文件 1234567891011121314151617181920&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 指定加载的配置文件 ，通过参数contextConfigLocation加载 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-web.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; （3）将服务提供者工程中的HelloService接口复制到当前工程 （4）编写Controller 12345678910111213141516171819202122package com.itheima.controller;import com.alibaba.dubbo.config.annotation.Reference;import com.itheima.service.HelloService;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;@Controller@RequestMapping("/demo")public class HelloController &#123; @Reference private HelloService helloService; @RequestMapping("/hello") @ResponseBody public String getName(String name)&#123; //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; &#125;&#125; 注意：Controller中注入HelloService使用的是Dubbo提供的@Reference注解 （5）在src/main/resources下创建applicationContext-web.xml 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --&gt; &lt;dubbo:application name="dubbodemo-consumer" /&gt; &lt;!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--&gt; &lt;dubbo:registry address="zookeeper://192.168.134.129:2181"/&gt; &lt;!-- 扫描的方式暴露接口 --&gt; &lt;dubbo:annotation package="com.itheima.controller" /&gt;&lt;/beans&gt; （6）运行测试 tomcat7:run启动 在浏览器输入http://localhost:8082/demo/hello.do?name=Jack，查看浏览器输出结果 思考一：上面的Dubbo入门案例中我们是将HelloService接口从服务提供者工程(dubbodemo_provider)复制到服务消费者工程(dubbodemo_consumer)中，这种做法是否合适？还有没有更好的方式？ 答：这种做法显然是不好的，同一个接口被复制了两份，不利于后期维护。更好的方式是单独创建一个maven工程，将此接口创建在这个maven工程中。需要依赖此接口的工程只需要在自己工程的pom.xml文件中引入maven坐标即可。 思考二：在服务消费者工程(dubbodemo_consumer)中只是引用了HelloService接口，并没有提供实现类，Dubbo是如何做到远程调用的？ 答：Dubbo底层是基于代理技术为HelloService接口创建代理对象，远程调用是通过此代理对象完成的。可以通过开发工具的debug功能查看此代理对象的内部结构。另外，Dubbo实现网络传输底层是基于Netty框架完成的。 思考三：上面的Dubbo入门案例中我们使用Zookeeper作为服务注册中心，服务提供者需要将自己的服务信息注册到Zookeeper，服务消费者需要从Zookeeper订阅自己所需要的服务，此时Zookeeper服务就变得非常重要了，那如何防止Zookeeper单点故障呢？ 答：Zookeeper其实是支持集群模式的，可以配置Zookeeper集群来达到Zookeeper服务的高可用，防止出现单点故障。 5. Dubbo管理控制台我们在开发时，需要知道Zookeeper注册中心都注册了哪些服务，有哪些消费者来消费这些服务。我们可以通过部署一个管理中心来实现。其实管理中心就是一个web应用，部署到tomcat即可。 5.1 安装安装步骤： （1）将资料中的dubbo-admin-2.6.0.war文件复制到tomcat的webapps目录下 （2）启动tomcat，此war文件会自动解压 （3）修改WEB-INF下的dubbo.properties文件，注意dubbo.registry.address对应的值需要对应当前使用的Zookeeper的ip地址和端口号 ​ dubbo.registry.address=zookeeper://192.168.134.129:2181​ dubbo.admin.root.password=root​ dubbo.admin.guest.password=guest （4）重启tomcat 5.2 使用操作步骤： （1）访问http://localhost:8080/dubbo-admin-2.6.0/，输入用户名(root)和密码(root) （2）启动服务提供者工程和服务消费者工程，可以在查看到对应的信息 6. Dubbo相关配置说明6.1 包扫描1&lt;dubbo:annotation package="com.itheima.service" /&gt; 服务提供者和服务消费者都需要配置，表示包扫描，作用是扫描指定包(包括子包)下的类。 如果不使用包扫描，也可以通过如下配置的方式来发布服务： 12&lt;bean id="helloService" class="com.itheima.service.impl.HelloServiceImpl" /&gt;&lt;dubbo:service interface="com.itheima.api.HelloService" ref="helloService" /&gt; 作为服务消费者，可以通过如下配置来引用服务： 12&lt;!-- 生成远程服务代理，可以和本地bean一样使用helloService --&gt;&lt;dubbo:reference id="helloService" interface="com.itheima.api.HelloService" /&gt; 上面这种方式发布和引用服务，一个配置项(dubbo:service、dubbo:reference)只能发布或者引用一个服务，如果有多个服务，这种方式就比较繁琐了。推荐使用包扫描方式。 6.2 协议1&lt;dubbo:protocol name="dubbo" port="20880"/&gt; 一般在服务提供者一方配置，可以指定使用的协议名称和端口号。 其中Dubbo支持的协议有：dubbo、rmi、hessian、http、webservice、rest、redis等。 推荐使用的是dubbo协议。 dubbo 协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。 也可以在同一个工程中配置多个协议，不同服务可以使用不同的协议，例如： 1234567&lt;!-- 多协议配置 --&gt;&lt;dubbo:protocol name="dubbo" port="20880" /&gt;&lt;dubbo:protocol name="rmi" port="1099" /&gt;&lt;!-- 使用dubbo协议暴露服务 --&gt;&lt;dubbo:service interface="com.itheima.api.HelloService" ref="helloService" protocol="dubbo" /&gt;&lt;!-- 使用rmi协议暴露服务 --&gt;&lt;dubbo:service interface="com.itheima.api.DemoService" ref="demoService" protocol="rmi" /&gt; 6.3 启动时检查1&lt;dubbo:consumer check="false"/&gt; 上面这个配置需要配置在服务消费者一方，如果不配置默认check值为true。Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，以便上线时，能及早发现问题。可以通过将check值改为false来关闭检查。 建议在开发阶段将check值设置为false，在生产环境下改为true。 6.4 负载均衡负载均衡（Load Balance）：其实就是将请求分摊到多个操作单元上进行执行，从而共同完成工作任务。 在集群负载均衡时，Dubbo 提供了多种均衡策略（包括随机、轮询、最少活跃调用数、一致性Hash），缺省为random随机调用。 配置负载均衡策略，既可以在服务提供者一方配置，也可以在服务消费者一方配置，如下： 12345678910111213141516@Controller@RequestMapping("/demo")public class HelloController &#123; //在服务消费者一方配置负载均衡策略 @Reference(check = false,loadbalance = "random") private HelloService helloService; @RequestMapping("/hello") @ResponseBody public String getName(String name)&#123; //远程调用 String result = helloService.sayHello(name); System.out.println(result); return result; &#125;&#125; 1234567//在服务提供者一方配置负载均衡@Service(loadbalance = "random")public class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return "hello " + name; &#125;&#125; 可以通过启动多个服务提供者来观察Dubbo负载均衡效果。 注意：因为我们是在一台机器上启动多个服务提供者，所以需要修改tomcat的端口号和Dubbo服务的端口号来防止端口冲突。 在实际生产环境中，多个服务提供者是分别部署在不同的机器上，所以不存在端口冲突问题。 7. 解决Dubbo无法发布被事务代理的Service问题前面我们已经完成了Dubbo的入门案例，通过入门案例我们可以看到通过Dubbo提供的标签配置就可以进行包扫描，扫描到@Service注解的类就可以被发布为服务。 但是我们如果在服务提供者类上加入@Transactional事务控制注解后，服务就发布不成功了。原因是事务控制的底层原理是为服务提供者类创建代理对象，而默认情况下Spring是基于JDK动态代理方式创建代理对象，而此代理对象的完整类名为com.sun.proxy.$Proxy42（最后两位数字不是固定的），导致Dubbo在发布服务前进行包匹配时无法完成匹配，进而没有进行服务的发布。 7.1 问题展示在入门案例的服务提供者dubbodemo_provider工程基础上进行展示 操作步骤： （1）在pom.xml文件中增加maven坐标 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt; （2）在applicationContext-service.xml配置文件中加入数据源、事务管理器、开启事务注解的相关配置 1234567891011121314&lt;!--数据源--&gt;&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" destroy-method="close"&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="root" /&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/test" /&gt;&lt;/bean&gt;&lt;!-- 事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt;&lt;/bean&gt;&lt;!--开启事务控制的注解支持--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; 上面连接的数据库可以自行创建 （3）在HelloServiceImpl类上加入@Transactional注解 （4）启动服务提供者和服务消费者，并访问 上面的错误为没有可用的服务提供者 查看dubbo管理控制台发现服务并没有发布，如下： 可以通过断点调试的方式查看Dubbo执行过程，Dubbo通过AnnotationBean的postProcessAfterInitialization方法进行处理 7.2 解决方案通过上面的断点调试可以看到，在HelloServiceImpl类上加入事务注解后，Spring会为此类基于JDK动态代理技术创建代理对象，创建的代理对象完整类名为com.sun.proxy.$Proxy35，导致Dubbo在进行包匹配时没有成功（因为我们在发布服务时扫描的包为com.itheima.service），所以后面真正发布服务的代码没有执行。 解决方式操作步骤： （1）修改applicationContext-service.xml配置文件，开启事务控制注解支持时指定proxy-target-class属性，值为true。其作用是使用cglib代理方式为Service类创建代理对象 12&lt;!--开启事务控制的注解支持--&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/&gt; （2）修改HelloServiceImpl类，在Service注解中加入interfaceClass属性，值为HelloService.class，作用是指定服务的接口类型 1234567@Service(interfaceClass = HelloService.class)@Transactionalpublic class HelloServiceImpl implements HelloService &#123; public String sayHello(String name) &#123; return "hello " + name; &#125;&#125; 此处也是必须要修改的，否则会导致发布的服务接口为SpringProxy，而不是HelloService接口，如下：]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习IO流篇]]></title>
    <url>%2F2019%2F06%2F06%2FJava%E5%AD%A6%E4%B9%A0IO%E6%B5%81%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是IO？一种数据的流动，按照流动的方向，以内存为基准，分为 输入input 和 输出output ，即流向内存是输入流，流出内存的输出流。Java中I/O操作主要是指使用 java.io 包下的内容，进行输入、输出操作。 输入也叫做读取数据， 输出也叫做作写出数据。 学习IO流的目的？实现数据持续化操作 IO流的分类？根据数据的流向分为： 输入流和输出流。输入流 ：把数据从 其他设备 上读取到 内存 中的流。输出流 ：把数据从 内存 中写出到 其他设备 上的流。根据数据的类型分为： 字节流和字符流。字节流 ：以字节为单位，读写数据的流。字符流 ：以字符为单位，读写数据的流。 顶级父类 输入流 输出流字节流 字节输入流 字节输出流 InputStream OutputStream字符流 字符输入流 字节输出 Reader Writer 字节输出流【OutputStream】java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流。public void write(byte[] b, int off, int len) ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。public abstract void write(int b) ：将指定的字节输出流。close方法，当完成流的操作时，必须调用此方法，释放系统资源 FileOutputStream类OutputStream 有很多子类，我们从最简单的一个子类开始。java.io.FileOutputStream 类是文件输出流，用于将数据写出到文件。 构造方法public FileOutputStream(File file) ：创建文件输出流以写入由指定的 File对象表示的文件。public FileOutputStream(String name) ： 创建文件输出流以指定的名称写入文件。 创建一个流对象时，必须传入一个文件路径。该路径下，如果没有这个文件，会创建该文件。如果有这个文件，会清空这个文件的数据。 构造举例，代码如下： 123456789public class FileOutputStreamConstructor throws IOException &#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileOutputStream fos = new FileOutputStream(file); // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("b.txt"); &#125;&#125; 写出字节数据1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 写出数据 fos.write(97); // 写出第1个字节 fos.write(98); // 写出第2个字节 fos.write(99); // 写出第3个字节 // 关闭资源 fos.close(); &#125;&#125;输出结果：abc 数据追加续写public FileOutputStream(File file, boolean append) ： 创建文件输出流以写入由指定的javaFile对象表示的文件。public FileOutputStream(String name, boolean append) ： 创建文件输出流以指定的名称写入文件。 这两个构造方法，参数中都需要传入一个boolean类型的值， true 表示追加数据， false 表示清空原有数据。这样创建的输出流对象，就可以指定是否追加续写了 代码使用演示： 1234567891011121314public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"，true); // 字符串转换为字节数组 byte[] b = "abcde".getBytes(); // 写出从索引2开始，2个字节。索引2是c，两个字节，也就是cd。 fos.write(b); // 关闭资源 fos.close(); &#125;&#125;文件操作前：cd文件操作后：cdabcde 写出换行Windows系统里，换行符号是 \r\n 。把 以指定是否追加续写了，代码使用演示： 1234567891011121314151617181920212223public class FOSWrite &#123; public static void main(String[] args) throws IOException &#123; // 使用文件名称创建流对象 FileOutputStream fos = new FileOutputStream("fos.txt"); // 定义字节数组 byte[] words = &#123;97,98,99,100,101&#125;; // 遍历数组 for (int i = 0; i &lt; words.length; i++) &#123; // 写出一个字节 fos.write(words[i]); // 写出一个换行, 换行符号转成数组写出 fos.write("\r\n".getBytes()); &#125; // 关闭资源 fos.close(); &#125;&#125;输出结果：abcde 字节输入流【InputStream】java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。public abstract int read() ： 从输入流读取数据的下一个字节。 提升为int类型，读取到文件末尾，返回 -1。public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。【返回读取到的有效字节个数】，读取到末尾时，返回 -1。使用数组读取，每次读取多个字节，减少了系统间的IO操作次数，从而提高了读写的效率，建议开发中使用。 FileInputStream类java.io.FileInputStream 类是文件输入流，从文件中读取字节。 构造方法FileInputStream(File file) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。FileInputStream(String name) ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。当你创建一个流对象时，必须传入一个文件路径。该路径下，如果没有该文件,会抛出FileNotFoundException 。 构造举例，代码如下： 123456789public class FileInputStreamConstructor throws IOException&#123; public static void main(String[] args) &#123; // 使用File对象创建流对象 File file = new File("a.txt"); FileInputStream fos = new FileInputStream(file); // 使用文件名称创建流对象 FileInputStream fos = new FileInputStream("b.txt"); &#125;&#125; 读取字节数据读取字节： read 方法，每次可以读取⼀个字节的数据，提升为int类型，读取到文件末尾，返回 -1 ，代码使用户演示： 1234567891011121314151617181920212223242526272829public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream("read.txt"); // 读取数据，返回一个字节 int read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); read = fis.read(); System.out.println((char) read); // 读取到末尾,返回-1 read = fis.read(); System.out.println( read); // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde-1 循环改进读取方式，代码使用演示： 1234567891011121314151617181920public class FISRead &#123; public static void main(String[] args) throws IOException&#123; // 使用文件名称创建流对象 FileInputStream fis = new FileInputStream("read.txt"); // 定义变量，保存数据 int b ； // 循环读取 while ((b = fis.read())!=-1) &#123; System.out.println((char)b); &#125; // 关闭资源 fis.close(); &#125;&#125;输出结果：abcde 字符输入流【Reader】java.io.Reader 抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。public void close() ：关闭此流并释放与此流相关联的任何系统资源。public int read() ： 从输入流读取一个字符。public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf 中 。 FileReader类java.io.FileReader 类是读取字符文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。 字符编码：字节与字符的对应规则。 Windows系统的中文编码默认是GBK编码表。 idea中UTF-8 字节缓冲区：一个字节数组，用来临时存储字节数据。 构造方法 FileReader(File file) ： 创建一个新的 FileReader ，给定要读取的File对象。 FileReader(String fileName) ： 创建一个新的 FileReader ，给定要读取的文件的名称。 当你创建一个流对象时，必须传入一个文件路径。类似于FileInputStream 。 字符输出流【Writer】java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节输出流的基本共性功能方法。public abstract void close() ：关闭此输出流并释放与此流相关联的任何系统资源。public abstract void flush() ：刷新此输出流并强制任何缓冲的输出字符被写出。public void write(int c) ：写出一个字符。public void write(char[] cbuf) ：将 b.length字符从指定的字符数组写出此输出流。public abstract void write(char[] b, int off, int len) ：从指定的字符数组写出 len字符，从偏移量 off开始输出到此输出流。public void write(String str) ：写出一个字符串。 FileWriter类java.io.FileWriter 类是写出字符到文件的便利类。构造时使用系统默认的字符编码和默认字节缓冲区。构造方法FileWriter(File file) ： 创建一个新的 FileWriter，给定要读取的File对象。FileWriter(String fileName) ： 创建一个新的 FileWriter，给定要读取的文件的名称。 关闭和刷新因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要 flush 方法了。 flush ：刷新缓冲区，流对象可以继续使用。close ：关闭流，释放系统资源。关闭前会刷新缓冲区。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习ssm整合篇]]></title>
    <url>%2F2019%2F06%2F03%2FJava%E5%AD%A6%E4%B9%A0ssm%E6%95%B4%E5%90%88%E7%AF%87%2F</url>
    <content type="text"><![CDATA[框架 文件名称 用途及配置内容 mybatis sqlMapConfig.xml 配置mybatis的运行时环境，与spring整合以后，目前只需要配置别名 springmvc springmvc.xml 配置springmvc框架的环境，基础配置有：组件扫描controller配置处理器映射器配置处理器适配器配置视图解析器 配置自定义转换器配置异常处理器配置文件上传解析器配置拦截器 spring applicationContext-dao.xml 配置spring管理的持久层对象：数据源对象（dataSource）mybatis核心对象（SqlSessionFactory）mapper扫描器对象（MapperScannerConfigurer） spring applicationContext-service.xml 配置spring管理的业务层对象：配置组件扫描service spring applicationContext-trans.xml 配置spring管理的声明式事务：配置事务管理器（transactionManager）配置通知（txAdvice）配置切面（aop:config） 公共 db.properties 配置数据库连接池的属性信息 公共 log4j.properties 配置log4j打印日志 公共 web.xml 配置web项目的描述信息：配置全局参数加载spring配置文件配置spring监听器（ContextLoaderListener）配置字符集编码过滤器（CharacterEncodingFilter）配置springmvc前端控制器（DispatcherServlet）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习Spring篇]]></title>
    <url>%2F2019%2F05%2F14%2FJava%E5%AD%A6%E4%B9%A0Spring%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Spring的理解?Spring是一个轻量级的开源框架。可以简化开发，使得我们只需要关心业务需求。常见的配置方式有三种：基于XML的配置、基于注解的配置、基于Java的配置。 以IOC（Inversion of Control）控制反转和AOP（Aspect Oriented Programming）面向切面编程为核心。提供表现层springmvc和持久层spring Jdbc的支持，是一个企业级应用解决方案的框架。 Ioc:控制反转，由原先的手动new对象变为由容器创建，解决了程序代码间耦合依赖问题，方便程序的功能拓展，其实现原理是通过解析配置文件，根据配置文件的信息，利用反射机制来创建对象，创建好的对象放在map容器中供程序使用。 Di:依赖注入是IOC的具体实现，将对象或者数据赋值给对象的属性，解决了属性赋值依赖问题，实现了松耦合。实现原理可以是构造注入、set方式注入以及接口注入。 Aop：面向切面编程，可以对方法功能进行增强，解决了在不修改原来代码的基础上实现对方法的增强，提高代码复用性。实现原理是动态代理和cglib代理。 Aop常见的应用：权限认证 日志 事务 懒加载 上下文处理 错误跟踪（异常捕获）缓存Spring优点： IOC、AOP、DI、声明式事务…….. Spring缺点： 配置很重、JAR依赖问题很严重]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习多线程篇]]></title>
    <url>%2F2019%2F04%2F17%2FJava%E5%AD%A6%E4%B9%A0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%AF%87%2F</url>
    <content type="text"><![CDATA[线程创建方式有几种？他们的区别是什么？,线程池有什么作用？线程同步有几种方式？ 线程创建方式： 1）继承Thread类创建线程； 2）实现Runnable接口创建线程； 3）使用Callable和Future创建线程； 4）使用线程池例如用Executor框架。 区别： 1、线程只是实现Runnable或实现Callable接口，还可以继承其他类，这种方式下，多个线程可以共享一个target对象，非常适合多线程处理同一份资源的情形。 2、继承Thread类的线程类不能再继承其他父类（Java单继承决定）。 3、Callable和Future创建线程可以有返回值。 4、前三种的线程如果创建关闭频繁会消耗系统资源影响性能，而使用线程池可以不用线程的时候放回线程池，用的时候再从线程池取，项目开发中主要使用线程池。 线程池的作用：节省系统资源的开销和创建销毁线程的时间，提高开发效率。 线程同步方式：https://my.oschina.net/locust/blog/2244731]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习集合篇]]></title>
    <url>%2F2019%2F04%2F07%2FJava%E5%AD%A6%E4%B9%A0%E9%9B%86%E5%90%88%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、Collection 单列集合Collection 作为单列集合的根接口，子接口List 和 Set 接口均继承父类 Collection 接口。 1、List 集合接口下的子类在List接口下，我们常用的子类有三个，分别是ArrayList、LinkedList 和 Vector，List 集合中元素是有序的，存和取的顺序一致，有索引，可以存储重复元素。 2.1 ArrayList（优先考虑）ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。 线程不安全，效率高。 2.2 Vector（JDK 1.0出现，线程安全）底层数据结构是数组，查询快，增删慢。线程安全，效率低。Vector相对ArrayList查询慢(线程安全的)。Vector相对LinkedList增删慢(数组结构)。 2.3 LinkedList底层数据结构是链表，查询慢，增删快。线程不安全，效率高。 2.4 Vector和 ArrayList 的区别Vector是线程安全的,效率低。ArrayList是线程不安全的,效率高。共同点:都是数组实现的。 2.5 ArrayList和LinkedList的区别ArrayList底层是数组结构,查询和修改快，时间复杂度为1。LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢，时间复杂度为n。共同点:都是线程不安全的。 ArrayList集合的四种遍历方法ArrayList的遍历方法可以总结为以下四种形式，分别是迭代器迭代实现、增强for循环实现、通过索引实现、通过集合转换为数组进行遍历数组实现。显然，我们在开发中优先采用的是前两种遍历方式来实现。 2、Set集合接口下的子类Set 接口下的两个常用子类是 HashSet（无序存储，底层哈希算法实现）、 TreeSet（有序存储，底层二叉树算法实现）和 HashSet的子类LInkedHashSet 集合。Set 接口与 List 接口最大的区别就是 Set 接口的内容不允许重复元素的存和取是无序的，及存和取的顺序不一致，没有索引的存在，也不可以存储重复的元素。 HashSet 原理（如何保证元素的唯一性）使用 Set 集合都是需要去掉重复元素的，如果在存储的时候逐个 equals() 比较，效率肯定很低，哈希算法提高了去重的效率，进而降低了使用 equals() 方法的次数。当 HashSet 调用 add() 方法存储对象的时候，先调用对象的 hashCode() 得到一个哈希值，然后在集合中查找是否有哈希值相同的对象：如果没有哈希值相同的对象就直接存入到集合当中；如果有哈希值相同的对象，就和哈希值相同的对象逐个进行equals() 比较，比较结果为false就存入，true则不存。对于LinkedHashSet 是HashSet 的子类，底层是链表实现，也可以保证元素的唯一性，和HashSet 原理一样。 自定义类的对象存储到 HashSet 去重复类中必须重写hashCode() 和equals() 方法。当 hashcode 值相同时，才会调用 equals() 方法。对于两个对象相同而言，必须 hashCode() 和equals() 方法的返回值都相同才能判断为相同，二者缺一不可。 TreeSet有序存储底层是二叉树算法实现，一般在开发中不需要对存储的元素进行排序，所以在开发的时候大多用HashSet ，并且HashSet 的效率比较高，推荐使用。 TreeSet 是用来排序的，可以指定一个顺序，对象存入之后会按照指定的顺序排序。 使用方式：&lt;1&gt; 自然顺序（Comparable）TreeSet 类的add() 方法中会把存入的对象提升为Compara 类型；调用对象的comparaTo() 方法和集合中的对象进行比较；根据comparaTo() 方法的返回的结果进行存储，返回0，集合中只有一个元素；返回正数，集合怎么存就怎么取；返回负数，集合倒序存储。&lt;2&gt;比较器顺序(Comparator)创建TreeSet 的时候可以制定一个Comparator；如果传入了Comparator 的子类对象，那么TreeSet 就会按照比较器中的顺序排序；add() 方法内部会自动调用Comparator 接口中的compare() 方法排序。&lt;3&gt;两种方式的区别TreeSet构造函数什么都不传，默认按照类中Comparable 的顺序（没有就报错ClassCastExcep）；TreeSet 传入Comparator ，就优先按照Comparator 接口中的compare() 方法排序。 LinkedHashSet集合对于 LinkedHashSet 而言，继承于HashSet ，又基于 LinkedHashMap来实现的。底层使用 LinkedHashMap 来存储所有的元素，并用双向链表记录插入顺序，其所有的方法操作上与HashSet 相同，因此LinkedHashSet 的实现非常简单，在此不多赘述。 HashSet 与 TreeSet 集合的两种遍历方法HashSet 与 TreeSet 集合的两种遍历方式都是通过迭代器迭代遍历和通过增强for 循环遍历 二、Map双列集合下的子类Map接口下常用的子类有HashMap 、TreeMap 、Hashtable 和 ConcurrentHashMap 实现类，Map集合可以存储一对对象，即会一次性保存两个对象，存在key = value 结构，其最大的特点还是可以通过key 找到对应的value 值。 HashMap 原理（常用）1、HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。2、HashMap最多只允许一条记录的键为null，允许多条记录的值为null。3、HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。1、capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。2、loadFactor：负载因子，默认为 0.75。3、threshold：扩容的阈值，等于 capacity * loadFactorJava8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。 为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 为什么链表的长度为8是变成红黑树？为什么为6时又变成链表？ 底层使用哈希表，也就是数组+链表， 当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，当链表长度超过8个时会转化为红黑树， Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构。 TreeMapTreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的结果是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 Hashtable1、Hashtable 在JDK 1.0出现，犹如Vector ,很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。2、Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。3、Hashtable 的键和值都不允许有null 值。 ConcurrentHashMap1、ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。简单理解就是，ConcurrentHashMap 是一个 Segment 数组，它的内部细分了若干个小的 HashMap ，我们称之为段Segment，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 Segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 2、Segment 的大小也被称为ConcurrentHashMap 的并发度，默认情况下一个ConcurrentHashMap被进一步细分为16个段，既就是锁的并发度。 3、ConcurrentHashMap 的并发处理其实采用的技术是减少锁粒度。缩小锁定对象的范围，从而减小锁冲突的可能性，进而提高系统的并发能力。 4、ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 LinkedHashMap LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 HashMap 集合的遍历方法1、迭代器遍历 2、增强for循环遍历 HashMap和Hashtable的区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：HashMap允许键和值是null，而Hashtable不允许键或者值是null。Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。一般认为Hashtable是一个遗留的类。 HashMap和ConcurrentHashMap的区别？hashmap是线程不安全的，put时在多线程情况下，会形成环从而导致死循环。CoucurrentHashMap是线程安全的，采用分段锁机制，减少锁的粒度。 TreeMap的底层实现？TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。 红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质： 性质1：每个节点要么是红色，要么是黑色。 性质2：根节点永远是黑色的。 性质3：所有的叶节点都是空节点（即 null），并且是黑色的。 性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点） 性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客文章]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第一次使用hexo+github搭建个人博客，所以第一篇博客文章就写一下具体是如何搭建的。 1.准备搭建环境1.1安装node.js官网：http://nodejs.cn/download/ 可以根据不同平台系统选择需要的 Node.js 安装包。按照默认配置安装即可。 1.2安装git官网：https://git-scm.com/ Windows系统安装git过程中Configuring extra options的选项Enable Git Credential Manager(启用Git凭证管理器)需要NET Framework v4.5.1或更高版本。 2.安装hexoWindows系统下打开命令行，执行以下命令 选择安装淘宝镜像速度会比npm快很多 1npm install -g cnpm --registry=https://registry.npm.taobao.org 自动安装hexo框架 1cnpm install -g hexo-cli 显示版本号，显示出版本号就说明安装成功 1hexo -v 选择一个文件夹作为博客的根目录，进入该目录执行命令初始化hexo 1hexo init 在本地博客根目录下执行命令启动博客进行测试，默认http://localhost:4000/ 1hexo s 3.部署到github登录github 新建一个仓库，项目名必须以用户名.github.io的形式命名 修改在本地博客根目录下的配置文件_config.yml,冒号后面都要跟一个空格。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/codejuntao/codejuntao.github.io.git branch: master 执行命令发布到github，这里git要先配置好username和email 1hexo d 这样就搭建完成了，接下来就可以发表文章 4.发布文章hexo博客文件夹中 source 下的 _posts 中默认只有一个 hello-world.md，使用MarkDown编辑器，这里我使用的是typora软件 新建.md文件在第一行 右键 ==》 插入 ==》YAML Front Matter 输入title，作为文章标题 1title：我的第一篇博客 在博客文件夹下 右键 ==》 Git Bash Here 输入命令 123hexo g -- 用于生成静态页面hexo s -- 本地部署，完成后打开浏览器输入 localhost:4000 可以进行预览hexo d -- 部署到远程仓库上，如 github 如果觉得页面不好看，可以到 hexo 主题网站上找到自己喜欢的主题进项更换，也可以根据自己的喜好美化页面。]]></content>
  </entry>
</search>
