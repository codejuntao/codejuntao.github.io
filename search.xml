<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java学习Redis篇]]></title>
    <url>%2F2019%2F08%2F07%2FJava%E5%AD%A6%E4%B9%A0Redis%E7%AF%87%2F</url>
    <content type="text"><![CDATA[Redis是什么？Redis 是用 C 语言开发的一个开源的高性能键值对（key-value）数据库,非关系型数据库，并提供多种语言的API。 默认端口？默认过期时间？默认支持多大value？6379 不会过期。但是这样说有点绝对。一般情况是这样，当你配置中开启了超出最大内存限制就写磁盘的话，那么这些没有设置过期时间的key可能会被写到磁盘上。 redis的key和string类型value限制均为512MB。 怎么统计缓存命中率？Redis提供了INFO这个命令，能够随时监控服务器的状态，通过计算hits和miss，我们可以得到缓存的命中率。 使用redis有哪些好处？(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1) (2) 支持丰富数据类型，支持string，list，set，sorted set，hash (3) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除 (4) 可以持久化数据: ​ Redis 持久化的两种方式： ​ 1) RDB 格式：Redis DataBase，每过一段时间将内存中的数据写到硬盘上 ​ 2) AOF 格式：Append Only File，以日志的方式记录服务器上的每个操作，当服务器重启的时候，将日志中操作还原到内存中。 RDB 持久化机制优点: 1) 方便备份与恢复 整个 Redis 数据库将只包含一个文件，默认是 dump.rdb，这对于文件备份和恢复而言是非常完美的。因为我 们可以非常轻松的将一个单独的文件压缩后再转移到其它储介质上。一旦系统出现灾难性故障，我们可以非常 容易的进行恢复。 2) 性能最大化 对于 Redis 的服务进程而言，在开始持久化时，它唯一需要做的只是分叉出子进程，由子进程完成这些持久 化的工作，这样就可以极大的避免服务进程执行 IO 操作了。 3) 启动效率更高 相比于 AOF 机制，如果数据集很大，RDB 的启动效率会更高 使用redis有什么缺点？主要是四个问题(一)缓存和数据库双写一致性问题(二)缓存雪崩问题(三)缓存击穿问题(四)缓存的并发竞争问题 redis的数据类型，以及每种数据类型的使用场景?(一)String最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。 (二)hash这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 (三)list使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。 (四)set因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 (五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，参照另一篇《分布式之延时任务方案解析》，该文指出了sorted set可以用来做延时任务。最后一个应用就是可以做范围查找。 为什么使用Redis？在项目中使用redis，主要是从两个角度去考虑:性能和并发。 （一）性能 我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。当然，redis还具备可以做分布式锁等其他功能，但是如果只是为了分布式锁这些其他功能，完全还有其他中间件(如zookpeer等)代替，并不是非要使用redis。 我们在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。 （二）并发 在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这个时候，就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。 单线程的redis为什么这么快？(一)纯内存操作(二)单线程操作，避免了频繁的上下文切换(三)采用了非阻塞I/O多路复用机制 redis的过期策略以及内存淘汰机制?redis采用的是定期删除+惰性删除策略。 为什么不用定时删除策略?定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略. 定期删除+惰性删除是如何工作的呢?定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。 采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。 redis和数据库双写一致性问题?从理论上说，只要我们设置了键的过期时间，我们就能保证缓存和数据库的数据最终是一致的。因为只要缓存数据过期了，就会被删除。随后读的时候，因为缓存里没有，就可以查数据库的数据，然后将数据库查出来的数据写入到缓存中。 除了设置过期时间，我们还需要做更多的措施来尽量避免数据库与缓存处于不一致的情况发生。 采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 如何应对缓存穿透和缓存雪崩问题?缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。 解决方案:(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。 解决方案:(一)给缓存的失效时间，加上一个随机值，避免集体失效。(二)使用互斥锁，但是该方案吞吐量明显下降了。(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 I 从缓存A读数据库，有则直接返回 II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 III 更新线程同时更新缓存A和缓存B。 如何解决redis的并发竞争key问题?(1)如果对这个key操作，不要求顺序这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。(2)如果对这个key操作，要求顺序假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下 123系统A key 1 &#123;valueA 3:00&#125;系统B key 1 &#123;valueB 3:05&#125;系统C key 1 &#123;valueC 3:10&#125; 那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。 其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java学习集合篇]]></title>
    <url>%2F2019%2F04%2F07%2FJava%E5%AD%A6%E4%B9%A0%E9%9B%86%E5%90%88%E7%AF%87%2F</url>
    <content type="text"><![CDATA[一、Collection 单列集合Collection 作为单列集合的根接口，子接口List 和 Set 接口均继承父类 Collection 接口。 1、List 集合接口下的子类在List接口下，我们常用的子类有三个，分别是ArrayList、LinkedList 和 Vector，List 集合中元素是有序的，存和取的顺序一致，有索引，可以存储重复元素。 2.1 ArrayList（优先考虑）ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。 线程不安全，效率高。 2.2 Vector（JDK 1.0出现，线程安全）底层数据结构是数组，查询快，增删慢。线程安全，效率低。Vector相对ArrayList查询慢(线程安全的)。Vector相对LinkedList增删慢(数组结构)。 2.3 LinkedList底层数据结构是链表，查询慢，增删快。线程不安全，效率高。 2.4 Vector和 ArrayList 的区别Vector是线程安全的,效率低。ArrayList是线程不安全的,效率高。共同点:都是数组实现的。 2.5 ArrayList和LinkedList的区别ArrayList底层是数组结构,查询和修改快，时间复杂度为1。LinkedList底层是链表结构的,增和删比较快,查询和修改比较慢，时间复杂度为n。共同点:都是线程不安全的。 ArrayList集合的四种遍历方法ArrayList的遍历方法可以总结为以下四种形式，分别是迭代器迭代实现、增强for循环实现、通过索引实现、通过集合转换为数组进行遍历数组实现。显然，我们在开发中优先采用的是前两种遍历方式来实现。 2、Set集合接口下的子类Set 接口下的两个常用子类是 HashSet（无序存储，底层哈希算法实现）、 TreeSet（有序存储，底层二叉树算法实现）和 HashSet的子类LInkedHashSet 集合。Set 接口与 List 接口最大的区别就是 Set 接口的内容不允许重复元素的存和取是无序的，及存和取的顺序不一致，没有索引的存在，也不可以存储重复的元素。 HashSet 原理（如何保证元素的唯一性）使用 Set 集合都是需要去掉重复元素的，如果在存储的时候逐个 equals() 比较，效率肯定很低，哈希算法提高了去重的效率，进而降低了使用 equals() 方法的次数。当 HashSet 调用 add() 方法存储对象的时候，先调用对象的 hashCode() 得到一个哈希值，然后在集合中查找是否有哈希值相同的对象：如果没有哈希值相同的对象就直接存入到集合当中；如果有哈希值相同的对象，就和哈希值相同的对象逐个进行equals() 比较，比较结果为false就存入，true则不存。对于LinkedHashSet 是HashSet 的子类，底层是链表实现，也可以保证元素的唯一性，和HashSet 原理一样。 自定义类的对象存储到 HashSet 去重复类中必须重写hashCode() 和equals() 方法。当 hashcode 值相同时，才会调用 equals() 方法。对于两个对象相同而言，必须 hashCode() 和equals() 方法的返回值都相同才能判断为相同，二者缺一不可。 TreeSet有序存储底层是二叉树算法实现，一般在开发中不需要对存储的元素进行排序，所以在开发的时候大多用HashSet ，并且HashSet 的效率比较高，推荐使用。 TreeSet 是用来排序的，可以指定一个顺序，对象存入之后会按照指定的顺序排序。 使用方式：&lt;1&gt; 自然顺序（Comparable）TreeSet 类的add() 方法中会把存入的对象提升为Compara 类型；调用对象的comparaTo() 方法和集合中的对象进行比较；根据comparaTo() 方法的返回的结果进行存储，返回0，集合中只有一个元素；返回正数，集合怎么存就怎么取；返回负数，集合倒序存储。&lt;2&gt;比较器顺序(Comparator)创建TreeSet 的时候可以制定一个Comparator；如果传入了Comparator 的子类对象，那么TreeSet 就会按照比较器中的顺序排序；add() 方法内部会自动调用Comparator 接口中的compare() 方法排序。&lt;3&gt;两种方式的区别TreeSet构造函数什么都不传，默认按照类中Comparable 的顺序（没有就报错ClassCastExcep）；TreeSet 传入Comparator ，就优先按照Comparator 接口中的compare() 方法排序。 LinkedHashSet集合对于 LinkedHashSet 而言，继承于HashSet ，又基于 LinkedHashMap来实现的。底层使用 LinkedHashMap 来存储所有的元素，并用双向链表记录插入顺序，其所有的方法操作上与HashSet 相同，因此LinkedHashSet 的实现非常简单，在此不多赘述。 HashSet 与 TreeSet 集合的两种遍历方法HashSet 与 TreeSet 集合的两种遍历方式都是通过迭代器迭代遍历和通过增强for 循环遍历 二、Map双列集合下的子类Map接口下常用的子类有HashMap 、TreeMap 、Hashtable 和 ConcurrentHashMap 实现类，Map集合可以存储一对对象，即会一次性保存两个对象，存在key = value 结构，其最大的特点还是可以通过key 找到对应的value 值。 HashMap 原理（常用）1、HashMap根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。2、HashMap最多只允许一条记录的键为null，允许多条记录的值为null。3、HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。我们用下面这张图来介绍 HashMap 的结构。 大方向上，HashMap 里面是一个数组，然后数组中每个元素是一个单向链表。上图中，每个绿色的实体是嵌套类 Entry 的实例，Entry 包含四个属性：key, value, hash 值和用于单向链表的 next。1、capacity：当前数组容量，始终保持 2^n，可以扩容，扩容后数组大小为当前的 2 倍。2、loadFactor：负载因子，默认为 0.75。3、threshold：扩容的阈值，等于 capacity * loadFactorJava8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。 根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。 为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。 为什么链表的长度为8是变成红黑树？为什么为6时又变成链表？ 底层使用哈希表，也就是数组+链表， 当添加一个元素（key-value）时，就首先计算元素key的hash值，以此确定插入数组中的位置，但是可能存在同一hash值的元素已经被放在数组同一位置了，这时就添加到同一hash值的元素的后面，他们在数组的同一位置，但是形成了链表，同一各链表上的Hash值是相同的，当链表长度超过8个时会转化为红黑树， Hashmap基于数组实现的，通过对key的hashcode &amp; 数组的长度得到在数组中位置，如当前数组有元素，则数组当前元素next指向要插入的元素，这样来解决hash冲突的，形成了拉链式的结构。HashMap在JDK1.8的版本中引入了红黑树结构做优化，当链表元素个数大于等于8时，链表转换成树结构。 TreeMapTreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的结果是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。 Hashtable1、Hashtable 在JDK 1.0出现，犹如Vector ,很多映射的常用功能与HashMap类似，不同的是它继承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。2、Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。3、Hashtable 的键和值都不允许有null 值。 ConcurrentHashMap1、ConcurrentHashMap 和 HashMap 思路是差不多的，但是因为它支持并发操作，所以要复杂一些。简单理解就是，ConcurrentHashMap 是一个 Segment 数组，它的内部细分了若干个小的 HashMap ，我们称之为段Segment，Segment 通过继承 ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 Segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。 2、Segment 的大小也被称为ConcurrentHashMap 的并发度，默认情况下一个ConcurrentHashMap被进一步细分为16个段，既就是锁的并发度。 3、ConcurrentHashMap 的并发处理其实采用的技术是减少锁粒度。缩小锁定对象的范围，从而减小锁冲突的可能性，进而提高系统的并发能力。 4、ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁ReentrantLock，在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护一个HashEntry数组里的元素,当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。 LinkedHashMap LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 HashMap 集合的遍历方法1、迭代器遍历 2、增强for循环遍历 HashMap和Hashtable的区别？HashMap和Hashtable都实现了Map接口，因此很多特性非常相似。但是，他们有以下不同点：HashMap允许键和值是null，而Hashtable不允许键或者值是null。Hashtable是同步的，而HashMap不是。因此，HashMap更适合于单线程环境，而Hashtable适合于多线程环境。HashMap提供了可供应用迭代的键的集合，因此，HashMap是快速失败的。另一方面，Hashtable提供了对键的列举(Enumeration)。一般认为Hashtable是一个遗留的类。 HashMap和ConcurrentHashMap的区别？hashmap是线程不安全的，put时在多线程情况下，会形成环从而导致死循环。CoucurrentHashMap是线程安全的，采用分段锁机制，减少锁的粒度。 TreeMap的底层实现？TreeMap 的实现就是红黑树数据结构，也就说是一棵自平衡的排序二叉树，这样就可以保证当需要快速检索指定节点。 红黑树的插入、删除、遍历时间复杂度都为O(lgN)，所以性能上低于哈希表。但是哈希表无法提供键值对的有序输出，红黑树因为是排序插入的，可以按照键的值的大小有序输出。红黑树性质： 性质1：每个节点要么是红色，要么是黑色。 性质2：根节点永远是黑色的。 性质3：所有的叶节点都是空节点（即 null），并且是黑色的。 性质4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点） 性质5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。]]></content>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客文章]]></title>
    <url>%2F2019%2F04%2F05%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[第一次使用hexo+github搭建个人博客，所以第一篇博客文章就写一下具体是如何搭建的。 1.准备搭建环境1.1安装node.js官网：http://nodejs.cn/download/ 可以根据不同平台系统选择需要的 Node.js 安装包。按照默认配置安装即可。 1.2安装git官网：https://git-scm.com/ Windows系统安装git过程中Configuring extra options的选项Enable Git Credential Manager(启用Git凭证管理器)需要NET Framework v4.5.1或更高版本。 2.安装hexoWindows系统下打开命令行，执行以下命令 选择安装淘宝镜像速度会比npm快很多 1npm install -g cnpm --registry=https://registry.npm.taobao.org 自动安装hexo框架 1cnpm install -g hexo-cli 显示版本号，显示出版本号就说明安装成功 1hexo -v 选择一个文件夹作为博客的根目录，进入该目录执行命令初始化hexo 1hexo init 在本地博客根目录下执行命令启动博客进行测试，默认http://localhost:4000/ 1hexo s 3.部署到github登录github 新建一个仓库，项目名必须以用户名.github.io的形式命名 修改在本地博客根目录下的配置文件_config.yml,冒号后面都要跟一个空格。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/codejuntao/codejuntao.github.io.git branch: master 执行命令发布到github，这里git要先配置好username和email 1hexo d 这样就搭建完成了，接下来就可以发表文章 4.发布文章hexo博客文件夹中 source 下的 _posts 中默认只有一个 hello-world.md，使用MarkDown编辑器，这里我使用的是typora软件 新建.md文件在第一行 右键 ==》 插入 ==》YAML Front Matter 输入title，作为文章标题 1title：我的第一篇博客 在博客文件夹下 右键 ==》 Git Bash Here 输入命令 123hexo g -- 用于生成静态页面hexo s -- 本地部署，完成后打开浏览器输入 localhost:4000 可以进行预览hexo d -- 部署到远程仓库上，如 github 如果觉得页面不好看，可以到 hexo 主题网站上找到自己喜欢的主题进项更换，也可以根据自己的喜好美化页面。]]></content>
  </entry>
</search>
